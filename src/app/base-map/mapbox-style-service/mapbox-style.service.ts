// ----------------------------------------------------------------------
// Copyright 2022 Schlumberger. All rights reserved in Schlumberger
// authored and generated code (including the selection and
// arrangement of the source code base regardless of the authorship
// of individual files), but not including any copyright interest(s)
// owned by a third party related to source code or object code
// authored or generated by non-Schlumberger personnel.
//
// This source code includes Schlumberger confidential and/or
// proprietary information and may include Schlumberger trade secrets.
// Any use, disclosure and/or reproduction is prohibited unless
// authorized in writing.
//
// Publication Rights :: Schlumberger Private
// ----------------------------------------------------------------------
import { HttpClient, HttpStatusCode } from '@angular/common/http';
import { Inject, Injectable, InjectionToken } from '@angular/core';
import * as mapboxgl from 'mapbox-gl';
import { catchError, map, Observable, of, shareReplay } from 'rxjs';

export const BING_MAP_API_KEY = new InjectionToken('BingMapApiKey');

export interface BingImageryMetadataResponse {
  statusCode: HttpStatusCode;
  resourceSets: Array<BingImageryMetadataResourceSet>;
}

export interface BingImageryMetadataResourceSet {
  resources: Array<BingImageryMetadataResource>;
}

export interface BingImageryMetadataResource {
  imageUrl: string;
  imageUrlSubdomains: Array<string>;
  zoomMax: number;
  zoomMin: number;
}

// This service provides Mapbox style which is not owned or predefined by Mapbox.
// Currently it uses Bing Maps tiles. (https://docs.microsoft.com/en-us/bingmaps/rest-services/directly-accessing-the-bing-maps-tiles)
@Injectable({
  providedIn: 'root',
})
export class MapboxStyleService {
  private defaultStyle = 'mapbox://styles/mapbox/satellite-v9';
  private style$: Observable<mapboxgl.Style | string> | undefined;

  constructor(
    private httpClient: HttpClient,
    @Inject(BING_MAP_API_KEY) private readonly bingMapApiKey: string
  ) {}

  public get(apiKey?: string): Observable<mapboxgl.Style | string> {
    if (!this.style$) {
      this.style$ = this.load(apiKey || this.bingMapApiKey).pipe(
        shareReplay({ bufferSize: 1, refCount: true })
      );
    }
    return this.style$;
  }

  private load(apiKey: string): Observable<mapboxgl.Style | string> {
    const url = `https://dev.virtualearth.net/REST/V1/Imagery/Metadata/Aerial?output=json&include=ImageryProviders&key=${apiKey}`;

    return this.httpClient.get<BingImageryMetadataResponse>(url).pipe(
      map((response: BingImageryMetadataResponse) =>
        this.convertToStyle(response)
      ),
      catchError(() => of(this.defaultStyle))
    );
  }

  private convertToStyle(
    response: BingImageryMetadataResponse
  ): mapboxgl.Style | string {
    if (
      response.statusCode !== HttpStatusCode.Ok ||
      response.resourceSets.length < 1 ||
      response.resourceSets[0].resources.length < 1
    ) {
      return this.defaultStyle;
    }

    const resource = response.resourceSets[0].resources[0];
    const imageUrl = resource.imageUrl.replace('http', 'https');
    const tiles = resource.imageUrlSubdomains.map((subdomain: string) =>
      imageUrl.replace('{subdomain}', subdomain)
    );
    const style: mapboxgl.Style = {
      version: 8,
      sources: {
        'raster-tiles': {
          type: 'raster',
          tiles: tiles,
        },
      },
      layers: [
        {
          id: 'tiles',
          type: 'raster',
          source: 'raster-tiles',
          minzoom: resource.zoomMin || 0,
          maxzoom: resource.zoomMax || 22,
        },
      ],
    };

    return style;
  }
}
